I want to use the algorithms from the paper "Iterative Dynamics with Temporal Coherence" to resolve collisions between discs in my 2D physics simulation in C++. Collisions are represented as 
std::pair<Disc*, Disc*> collisions;
struct Disc { sf::Vector2d position, velocity; double radius; double mass; };
The paper contains these algorithms:
- Compute \overset{\cdot}{C} = JV
- Compute F_C = J^T\lambda
- Approximately solve Ax = b given x^0
- Approximately solve JB\lambda = \eta given \lambda^0
- Contact caching and queries

Which algorithms do I need? What do they do? How do I apply them to my situation?
Which physical quantities (F_C, J, \lambda, V, B, \eta) do I need? What are they for? How do I calculate them?

Let's start simple: Suppose there are only 2 discs and a single collision between them in this form std::pair<Disc*, Disc*> collisions; struct Disc { sf::Vector2d position, velocity; double radius; double mass; }; Give me a step-by-step recipe I can follow to solve this. What do I define, what do I solve, how to I resolve the collision?

We consider 2 circles (2D) and want to apply the methods described in "Iterative Dynamics with Temporal Coherence" for collision handling.

First, the paper states:
For a system of n bodies, the linear and angular velocities are stacked in a 6n-by-1 column vector 
V = (v1, omega1, ..., vn, omegan)^T
For my circles, I have no angular velocity, so omega = 0, and V is a 2n-by-1 column vector V = (v1, ..., vn).

Next, pairwise constraints Ck(xi, qi, xj, qj) = 0 are defined as abstract scalar functions. If s is the number of constraints, this is an s-by-1 column vector C. 
The time derivative of C gives the velocity contraint vector with 
dC/dt = J*V = 0
where J is the s-by-3n Jacobian.

For 2 circles, the constraint function would be C = ||p1 - p2| - (r1 + r2):
C >= 0 for just touching or separated
C < 0 for penetration

We want to enforce C >= 0.

dC/dt = (p1 - p2)/||p1 - p2|| * (p1' - p2')


This is where he lost me. Is the goal for C to be = 0? For 2 circles, I could define 
C = min(||p1 - p2|| - (r1 + r2), 0)
this would be 0 if the distance between the 2 circles is equal to or larger than the sum of their radii, and < 0 otherwise. Is this what was meant?
Next, I don't understand dC/dt = J*V = 0. What does this even mean?

Each contraint has an internal reaction force fc (and reaction torque, which is 0 for me). Again, we get 
Fc = (fc1, ..., fcn)^T 


So let's say I'm processing a frame. I found all overlaps between N circles in some sort of array/set std::set<std::pair<Disc*, Disc*>> collisions; of size M
Now I have to:
- Construct M: The diagonal entries for row i are m_i I_2, where I_2 is the 2x2 identity matrix, everything else is 0: diag(m_1 I_2, ..., m_N I_2)
- Construct M^{-1}: diag(m_1^{-1} I_2, ..., m_N^{-1} I_2)
- Construct V: Stacking velocities of all discs in collisions on top of each other (v_1, v_2, ..., v_N) 
- Construct J: For each collision pair of discs (i, j), append a row of  2N zeros, set columns 2i and 2i+1 to n^T and columns 2j and 2j+1 to -n^T with the normal vector n from i to j 
- Construct C: For each collision pair, append the row |r_1 - r_2| - (R_1 + R_2) 
- Solve the linear system \Delta t J M^{-1} J^T \lambda = -\beta C - JV^1 for \lambda (using PGS) 
- Calculate V^2 = V^1 + \Delta t M^{-1}J^{T}\lambda. 

I'll try to implement this now. Overall it was pretty difficult to understand the paper. How hard would you rate this to understand and implement in C++ on a scale of 1-10?
